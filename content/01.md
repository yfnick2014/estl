#条款1：仔细选择你的容器
###选项归纳###
- 标准STL序列容器：vector、string、deque和list
- 标准STL关联容器：set、multiset、map和multimap
- 非标准序列容器：slist和rope
- 非标准关联容器：hash_set、hash_multiset、hash_map和hash_multimap
- vector<char>可以作为string的替代品
- vector作为标准关联容器的替代品，有时候可以在时间和空间上都表现得比标准关联容器好
- 几种标准非STL容器，包括数组、bitset、valarray、stack、queue和priority_queue

###【STL官方指导方案】vector、list和deque###
vector、list和deque提供给程序员不同的复杂度，因此应该这么用：vector是一种可以默认使用的序列类型，当很频繁地对序列中部进行插入和删除时应该用list，当大部分插入和删除发生在序列的头或尾时可以选择deque这种数据结构。

###连续内存容器和基于节点的容器的区别###
- 连续内存容器（也叫做基于数组的容器）在一个或多个（动态分配）的内存块中保存它们的元素。如果一个新元素被插入或已存元素被删除，其他在同一个内存块中的元素必须向上或向下移动来为新元素提供空间或填充原来被删除的元素所占的空间。这种移动影响了效率和异常安全。标准的连续内存容器是vector、string和deque。非标准的rope也是连续内存容器。

- 基于节点的容器在每个内存块（动态分配）中只保存一个元素。容器元素的插入或删除只影响指向节点的指针，而不是节点自己的内容。所以当有东西插入或删除时，元素值不需要移动。

###Scott Meyers的建议###
- 你需要“可以在容器的任意位置插入一个新元素”的能力吗？如果是，你需要序列容器，关联容器做不到。
- 你关心元素在容器中的顺序吗？如果不，散列容器就是可行的选择。否则，你要避免使用散列容器。
- 必须使用标准C++中的容器吗？如果是，就可以出去散列容器slist和rope。
- 你需要哪一类迭代器？如果必须是随机访问迭代器，在技术上你就只能限于vector、deque和string，但你也可能会考虑rope。如果需要双向迭代器，你就用不了slist和散列容器的一般实现。
- 当插入或删除数据时，是否非常在意容器内现有元素的移动？如果是，你就必须放弃连续内存容器。
- 容器中的数据的内存布局需要兼容C吗？如果是，你就只能用vector。
- 查找速度很重要吗？如果是，你就应该看看散列容器，排序的vector和标准的关联容器。
- 你介意如果容器的底层使用了引用计数吗？如果是，你就得避开string，因为string的实现是用引用计数。你也不能用rope，因为权威的rope实现是基于引用计数的。考虑使用vector<char>。
- 你需要插入和删除的事务性语义吗？如果是，你就需要使用基于节点的容器。如果你需要多元素插入的事务性语义，你就应该选择list，因为list是唯一提供多元素插入事务性语义的标准容器。
- 你要把迭代器、指针和引用的失效次数减到最少吗？如果是，你就应该使用基于节点的容器，因为在这些容器上进行插入和删除不会使迭代器、指针和引用失效。一般来说，在连续内存容器上插入和删除会使所有指向容器的迭代器、指针和引用失效。
- 你需要具有以下特性的容器吗：1）可以使用随机访问迭代器；2）只要没有删除而且插入只发生在容器结尾，指针和引用的数据就不会失效？推荐使用deque。

需要考虑的因素：元素顺序、标准的一致性、迭代器能力、内存布局和C的兼容性、查找速度、因为引用计数造成的行为不规则、事务性语义的轻松实现、迭代器失效的条件、容器操作的算法复杂度。