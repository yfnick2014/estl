# estl
《Effective STL》 中文版 笔记
##目录
- 容器
  - [条款1：仔细选择你的容器](content/01.md)
  - 条款2：小心对“容器无关代码”的幻想
  - 条款3：使容器里对象的拷贝操作轻量而正确
  - 条款4：用empty来代替检查size()是否为0
  - 条款5：尽量使用区间成员函数代替它们的单元素兄弟
  - 条款6：警惕C++最令人恼怒的解析
  - 条款7：当使用new得指针的容器时，记得在销毁容器前delete那些指针
  - 条款8：永不建立auto_ptr的容器
  - 条款9：在删除选项中仔细选择
  - 条款10：注意分配器的协定和约束
  - 条款11：理解自定义分配器的正确用法
  - 条款12：对STL容器线程安全性的期待现实一些
- vector和string
  - 条款13：尽量使用vector和string来替代动态分配的数组
  - 条款14：使用reserve来避免不必要的重新分配
  - 条款15：小心string实现的多样性
  - 条款16：如何将vector和string的数据传给遗留的API
  - 条款17：使用“交换技术”来修整过剩容量
  - 条款18：避免使用vector<bool>
- 关联容器
  - 条款19：了解相等和等价的区别
  - 条款20：为指针的关联容器指定比较类型
  - 条款21：永远让比较函数对相等的值返回false
  - 条款22：避免原地修改set和multiset的键
  - 条款23：考虑用有序vector替代关联容器
  - 条款24：当关乎效率时应该在map::operator[]和map-insert之间仔细选择
  - 条款25：熟悉非标准散列容器
- 迭代器
  - 条款26：尽量用iterator代替const_iterator, reverse_iterator和const_reverse_iterator
  - 条款27：用distance和advance把const_iterator转化成iterator
  - 条款28：了解如何通过reverse_iterator的base得到iterator
  - 条款29：需要一个一个字符输入时考虑使用istreambuf_iterator
- 算法
  - 条款30：确保目标区间足够大
  - 条款31：了解你的排序选择
  - 条款32：如果你真的想删除东西的话就在类似remove的算法后接上erase
  - 条款33：提防在指针的容器上使用类似remove的算法
  - 条款34：注意哪个算法需要有序区间
  - 条款35：通过mismatch或lexicographical比较实现简单的忽略大小写字符串比较
  - 条款36：了解copy_if的正确实现
  - 条款37：用accumulate或for_each来统计区间
- 仿函数、仿函数类、函数等
  - 条款38：把仿函数类设计为用于值传递
  - 条款39：用纯函数做判断式
  - 条款40：使仿函数类可适配
  - 条款41：了解使用ptr_fun、mem_fun和mem_fun_ref的原因
  - 条款42：确定less<T>表示operator<
- 使用STL编程
  - 条款43：尽量用算法调用代替手写循环
  - 条款44：尽量用成员函数代替同名的算法
  - 条款45：注意count、find、binary_search、lower_bound、upper_bound和equal_range的区别
  - 条款46：考虑使用函数对象代替函数作算法的参数
  - 条款47：避免产生只写代码
  - 条款48：总是#include适当的头文件
  - 条款49：学习破解有关STL的编译器诊断信息
  - 条款50：让自己熟悉有关STL的网站
